"""
<Program Name>
  inertialnav.r2py

<Started>
  15 July 2015

<Author>
  Seth Miller (NYU)

<Purpose>
  This is a script for estimating the position of a person walking
  between two known locations. Sensor data from the GPS, accelerometer,
  gyroscope, and magnetometer are backhauled to sensevis.poly.edu while 
  the acceleration and angular velocity of the device are integrated to
  estimate its position.

  *Note: The device must begin at rest to calibrate the acceleration due
  to gravity.

"""



getsensor = dy_import_module('getsensor.r2py')
sensevislib = dy_import_module('sensevislib.r2py')
dy_import_module_symbols('matrixmath.r2py')
dy_import_module_symbols('math.r2py')


XYZ = 3

lock = createlock()

pitch = 0
roll = 0
azimuth = 0

position = [0, 0, 0]
vel0 = [0, 0, 0]


# start all sensors at ~167Hz
getsensor.start_sensing(1, 6)


gsum = [0, 0, 0]
gcnt = 0
# Phone should be stationary
# while calibrating gravity
log('Calibrating gravity...\n')
while gcnt < 100:
  g = getsensor.get_acceleration()
  # add up each component
  for axis in range(XYZ):
    gsum[axis] += g[axis]
  gcnt += 1

# set gravity as the avg for each component
gravity = [[gsum[0]], [gsum[1]], [gsum[2]]]
log('Gravity: ', gravity, '\n')



# Some sensors start before others, so we
# need to wait until we get one with a timestamp
while 'time' not in getsensor.get_sensors():
  sleep(0.1)

log('Starting...')
# Collect sensor data, but 
while True:
"""
<Program Name>
  inertialnav.r2py

<Started>
  15 July 2015

<Author>
  Seth Miller (NYU)

<Purpose>
  This is a script for estimating the position of a person walking
  between two known locations. Sensor data from the GPS, accelerometer,
  gyroscope, and magnetometer are backhauled to sensevis.poly.edu while 
  the acceleration and angular velocity of the device are integrated to
  estimate its position.

  *Note: The device must begin at rest to calibrate the acceleration due
  to gravity.

"""



getsensor = dy_import_module('getsensor.r2py')
sensevislib = dy_import_module('sensevislib.r2py')
dy_import_module_symbols('matrixmath.r2py')
dy_import_module_symbols('math.r2py')


XYZ = 3

lock = createlock()

pitch = 0
roll = 0
azimuth = 0

position = [0, 0, 0]
vel0 = [0, 0, 0]


# start all sensors at ~167Hz
getsensor.start_sensing(1, 6)


gsum = [0, 0, 0]
gcnt = 0
# Phone should be stationary
# while calibrating gravity
log('Calibrating gravity...\n')
while gcnt < 100:
  g = getsensor.get_acceleration()
  # add up each component
  for axis in range(XYZ):
    gsum[axis] += g[axis]
  gcnt += 1

# set gravity as the avg for each component
gravity = [[gsum[0]], [gsum[1]], [gsum[2]]]
log('Gravity: ', gravity, '\n')



# Some sensors start before others, so we
# need to wait until we get one with a timestamp
while 'time' not in getsensor.get_sensors():
  sleep(0.1)

log('Starting...')
# Collect sensor data, but process it in another
# thread so we don't slow down the polling rate. 
while True:
  createthread(process(getsensor.get_sensors()))

  

# processes sensor data to estimate position
def process(sensordata):
  def func():
    # Quick! Let's slap on the gps location.
    # Even if we were asleep for a little bit
    # before we got here, gps probably isn't that
    # precise within the few meters we could have 
    # traveled since then anyhow.
    #
    # However, gps may be unavailable. . . 
    location = None
    try:
      location = getsensor.get_location()
    except LocationNotFoundException:
      pass

    # Open a connection to sensevis for backhauling
    sensevisfile = sensevislib.open('SensibilityTestbed/inertialnav/ground-truth-test')

    data = {'deviceID':'nexus5', 'gps':location, 'gravity':gravity}

    # Calculate time step (since last measurement)
    dt = sensordata['time'] - start
    
    # Make sure we didn't poll too fast
    if dt == 0:
      return

    data['time'] = sensordata['time']
    data['dt'] = dt 

    # Store raw sensor data
    data['gyroVel'] = [sensordata['pitch'], sensordata['roll'], sensordata['azimuth']]
    data['phoneAcc'] = [[sensordata['xforce']], [sensordata['yforce']], [sensordata['zforce']]]
    data['magnet'] = [sensordata['xMag'], sensordata['yMag'], sensordata['zMag']]

    # Other processing threads may be running,
    # so we need to protect the current orientation,
    # position, and initial velocity.
    lock.acquire(True)
    ################################### CRITICAL REGION #######################################

    # remember timestamp for next thread
    start = sensordata['time']

    # Integrate gyro to get orientation angles
    pitch += sensordata['pitch'] * dt
    roll += sensordata['roll'] * dt
    azimuth += sensordata['azimuth'] * dt

    # Store orientation angles  
    data['gyroAngle'] = [pitch, roll, azimuth]
   
    # Euler rotation matrices for orienting in the phone's frame of reference 
    rotationx = [[1, 0, 0], [0, math_cos(pitch), -math_sin(pitch)], [0, math_sin(pitch), math_cos(pitch)]]
    rotationy = [[math_cos(roll), 0, math_sin(roll)], [0, 1, 0], [-math_sin(roll), 0, math_cos(roll)]]
    rotationz = [[math_cos(azimuth), -math_sin(azimuth), 0], [math_sin(azimuth), math_cos(azimuth), 0], [0, 0, 1]]

    # Combined rotation transformation
    rotation = matrix_multiply(matrix_multiply(rotationz, rotationy), rotationx)
    
    # Invert rotation matrix to get phone-to-world transformation
    transform = matrix_inverse(rotation)
    
    # Transform phone acc to real world acc
    acc = matrix_multiply(transform, data['phoneAcc'])
  
    data['vel0'] = vel0

    vel = [0, 0, 0]
    for axis in range(XYZ):
      # Subtract gravity from acceleration.
      linear_acc[axis] = acc[axis][0] - gravity[axis][0]
      # Integrate linear acc to get velocity.
      vel[axis] = linear_acc[axis] * dt
      # Double integrate linear acc to get position.
      position[axis] += 0.5 * vel * dt + vel0[axis]
      # Update velocity for next time step.
      vel0[axis] += vel

    data['pos'] = position
    ################################# ENDOF CRITICAL REGION ###################################
    lock.release()

    data['acc'] = acc
    data['linearAcc'] = linear_acc
    data['vel'] = vel

    # Store rotation matrices
    data['R(x)'] = rotationx
    data['R(y)'] = rotationy
    data['R(z)'] = rotationz
    data['R(z)R(y)R(x)'] = rotation
    data['R^-1'] = transform

    # backhaul the data and finish up
    sensevisfile.write(data)
    sensevisfile.close()

  return func
